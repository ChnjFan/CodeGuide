# 内存池

内存池提前向操作系统申请一块连续的大内存，解决频繁向操作系统申请内存带来的系统调用和开销。

[TOC]

## 为什么需要内存池

传统内存分配，如`new/delete`、`malloc/free` 存在的问题：

- **性能开销大**：每次调用`malloc`/`new`都需要向操作系统申请内存，操作系统需要遍历空闲内存块、处理内存碎片、更新内存管理数据结构，频繁的小内存分配会带来大量的系统调用和开销。
- **内存碎片**：频繁分配和释放不同大小的内存块，会导致内存空间中出现大量无法被利用的小空闲块（外部碎片），降低内存利用率。
- **线程安全开销**：标准库的内存分配函数（如`malloc`）是线程安全的，内部会加锁，在高并发场景下，锁竞争会严重影响性能。

内存池的核心解决思路是：

1. 提前向操作系统申请一块连续的大内存，之后内存分配都在这块大内存中进行。
2. 内存耗尽时再按需扩展。
3. 释放内存先归还给内存池，而非直接还给操作系统。

## 核心实现原理

生产级的 C++ 内存池管理系统，融合了**多层级内存块管理**、**智能碎片整理**、**线程安全机制**和**高性能对象池**，旨在提供一个**高效、可靠、易用**的通用内存管理解决方案。

### 多层级内存块管理

采用分层设计将内存池分为三个不同级别的层次：

- 小块池（small_blocks_）：默认256KB，用于频繁的小对象分配（1B-256KB）。
- 中块池（medium_blocks_）：默认1MB，用于中等大小的对象分配（256KB-1MB）。
- 大块池（large_blocks_）：默认4MB，用于大对象分配（1MB-4MB）。

分层架构的核心优势在于**按需分配**和**减少浪费**。当应用程序请求某个大小的内存时，系统会根据请求大小自动选择最合适的内存块进行分配，避免了在过大的块中分配小对象造成的空间浪费，也避免了在过小的块中无法满足大对象需求的问题。



