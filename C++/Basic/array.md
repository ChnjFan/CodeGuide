# 数组

数组在栈内存中分配一块连续的内存空间，数组名是一个**常量表达式**，代表这块内存的起始地址。

```c++
int arr[5] = {1,2,3,4,5};
```

编译器生成汇编代码：

```assembly
movl   $0x1,-0x20(%rbp)
movl   $0x2,-0x1c(%rbp)
movl   $0x3,-0x18(%rbp)
movl   $0x4,-0x14(%rbp)
movl   $0x5,-0x10(%rbp)
```

当访问数组内部元素时，编译器会在编译期间计算访问的地址。当访问数组 `arr[1]` 元素时，汇编指令为：

```assembly
mov    -0x1c(%rbp),%eax
```

数组访问是**一次寻址，直接访问内存**，地址计算是在编译期完成，运行时只需要一条内存读取指令。

## 数组退化指针

很多情况下数组会退化成指针：

1. 作为函数参数：数组作为函数参数会退化成第一个元素的指针。
2. 赋值给指针：等价于 `&arr[0]`。
3. 算数运算：`int *p = arr + 2`。

`sizeof(arr)` 返回整个数组大小，不退化。

`int (*p)[5] = &arr;` 此时的 `p` 类型指向 `int[5]` 的指针，而不是 `int *`。

## 常见问题

1. **数组和指针有什么区别？**

答：数组和指针在内存布局和访问机制上有本质区别。数组是一块连续内存，数组名是常量表达式，访问时只需要一次寻址，地址计算在编译期完成。指针是变量，存储地址，访问时需要两次寻址。在类型系统中，数组类型包含大小信息，而指针不包含。虽然数组名在大多数情况下会退化成指针，但在 `sizeof` 和取地址运算时不会退化。

2. **数组和指针访问性能上的差异？**

理论上数组访问更快，因为少一次内存访问。但现代 CPU 有多级缓存和预取机制，大多数情况下这个差异可以忽略。真正有差异的是多级指针vs多维数组，比如 `int**` 需要多次寻址，而 `int arr[m][n]` 是连续内存，在图像处理这类大量访问的场景下，性能差异会很明显。