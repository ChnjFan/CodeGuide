# 多态

> 在C++中，多态是面向对象编程的一个重要特性，它允许不同的对象对同一消息做出不同的响应。

[TOC]

多态性可以提高代码的可扩展性和可维护性，主要分为静态多态和动态多态。

- 静态多态：模板、函数重载
- 动态多态：虚函数、继承

## 静态多态

静态多态也称为编译时多态，它在编译阶段就确定了要调用的函数。主要通过**模板**和**函数重载**来实现。

### 模板与泛型编程

模板是C++中实现泛型编程的重要工具，它允许编写与类型无关的代码。模板分为函数模板和类模板。

泛型函数的参数由关键字 `requires` 定义。

1. **使用模板提升代码抽象层级**

正确使用 `requires` 关键字避免过度约束。

泛型编程的目标是针对具有相似语义属性的类型集合，高效地泛化操作/算法。

- **算法约束**：算法必须通过概念 `requires` 明确约束模板参数的要求，避免直接使用运算符而不检查类型支持性。

```cpp
template<typename T>
requires Arithmetic<T>  // 明确约束T必须支持算术运算
T sum(vector<T>& v, T s) {
    for (auto x : v) s += x;
    return s;
}
```

- **概念构建**：允许定义简单概念作为构建块，但算法应使用足够强的概念来确保类型安全性。

```cpp
// 简单概念定义（作为构建块）
template<typename T>
concept Incrementable = requires(T t) { ++t; };  // 仅要求++操作

// 更复杂的概念（基于简单概念构建）
template<typename T>
concept Arithmetic = 
    Incrementable<T> &&          // 复用简单概念
    requires(T a, T b) {
        { a + b } -> std::same_as<T>;
        { a += b } -> std::same_as<T&>;
        // 其他算术操作...
    };
```

2. **使用模板表达适用于多种参数类型的算法**

STL 的基础就是使用模板来适用不同参数类型的算法实现。

除非确实需要支持多种模板参数类型，否则不要使用模板。避免过度抽象。

3. **使用模板来表达容器元素类型**

容器需要元素类型，将其作为模板参数表达具有通用性、可复用性和类型安全性。

C 语言在容器中通常使用 `void*` 来保存不同元素类型，并通过设置元素第一个字节为参数类型进行区分。

4. **静态多态和动态多态的互补**

使用静态多态实现动态多态：

```cpp
class Command {
    // 纯虚函数
};
// 实现类
template</*...*/>
class ConcreteCommand : public Command {
    // 实现虚函数
};
```

提供通用、便捷的静态绑定接口，但内部进行动态分发，从而实现统一的对象布局。例如`std::shared_ptr`的删除器所采用的类型擦除技术（但需避免过度使用类型擦除）。

类型擦除通过在独立编译边界后隐藏类型信息，会引入额外的间接层开销。

### 函数重载

同一作用域内，可以定义多个同名但参数列表不同的函数，编译器根据调用的实参类型和数量选择合适的函数。

1. **优先使用默认参数而非函数重载**

默认参数仅为单一实现提供替代接口，而一组重载函数无法保证始终实现相同的语义。使用默认参数可避免代码重复。

```cpp
void print(const string& s, format f = {});  // 带默认参数的单一函数
```

当一组函数用于对不同类型执行语义等价的操作时，不存在这种选择。

```cpp
void print(const char&);   // 打印字符
void print(int);           // 打印整数
void print(zstring);       // 打印自定义字符串类型
```

## 动态多态

动态多态也称为运行时多态，它在运行时才确定要调用的函数。主要通过**虚继承**和**虚函数**来实现。

