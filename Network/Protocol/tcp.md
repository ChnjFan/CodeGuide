# TCP 协议

TCP（Transmission Control Protocol，传输控制协议）是一种**面向连接的**、**可靠的**、**基于字节流**的传输层协议，由 IETF 的 RFC 793 定义。它在 IP 协议的基础上，提供了**可靠数据传输**、**流量控制**和**拥塞控制**等核心功能.。

[TOC]

## 协议报文

TCP 报文的基本头部固定 20 个字节，紧跟在 IP 数据报头部。

```shell
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-------------------------------+-------------------------------+
   |          Source Port          |       Destination Port        |
   +-------------------------------+-------------------------------+
   |                        Sequence Number                        |
   +---------------------------------------------------------------+
   |                    Acknowledgment Number                      |
   +-------+-------+-+-+-+-+-+-+-+-+-------------------------------+
   |  Data |       |C|E|U|A|P|R|S|F|                               |
   | Offset|Rsved  |W|C|R|C|S|S|Y|I|            Window             |
   |       |       |R|E|G|K|H|T|N|N|                               |
   +-------+-----------+-+-+-+-+-+-+-------------------------------+
   |           Checksum            |         Urgent Pointer        |
   +-------------------------------+-------------------------------+
   |                            Options                            |
   +---------------------------------------------------------------+
   |                             data                              |
   +---------------------------------------------------------------+
```

源端口和目的端口唯一标识 TCP 连接。

- Socket：IP + 端口
- 序列号：标识数据的每个字节序列
- 确认号：接收方期待接收的下一个序列号

## 核心特性

- 面向连接：单播协议，通过三次握手、四次挥手管理连接建立和释放。
- 可靠传输：序列号、确认机制、重传机制、校验和。
- 字节流：分组成多个 TCP 报文发送，应用层获取自己想要的数据长度。

### 面向连接

为了确保通信双方都能正常发送和接收数据，TCP 连接通过“三次握手”来建立连接，通过“四次挥手”释放连接。

#### 三次握手

使用 TCP 首部的控制字段管理连接，通过三次握手建立连接，交换通信双方的初始序列号。

建链前客户端的状态为 CLOSED，服务端启动并监听端口后初始状态为 LISTEN。

**建链流程**：

1. 客户端发送一个 SYN 报文给服务端，并携带客户端的初始序列号。客户端状态变为 SYN_SENT。
2. 服务端接收到 SYN 报文后状态变为 SYN_RCVD 并回复 SYN 报文给客户端，报文包含服务端的初始序列号，ACK 为客户端初始序列号 + 1。
3. 客户端应答服务端的 SYN 报文，将 ACK 设置为服务端初始序列号 + 1 回复给服务端。客户端状态更改为 ESTABLISHED。
4. 服务端接收到客户端应答后状态变更为 ESTABLISHED。

#### 四次挥手

通信双方都可以主动发送 FIN 报文关闭连接。

断链流程：

1. 连接关闭端发送 FIN 报文给对端，ACK 用于确认对端最近一次发送的数据，关闭端状态变更为 FIN_WAIT_1。
2. 被关闭一端发送应答报文，表明成功接收关闭请求，状态切换为 CLOSE_WAIT。
3. 关闭端接收到应答报文，状态切换为 FIN_WAIT_2，并启动定时器等待接收被关闭端的 FIN 报文。
4. 被关闭一端处理完应用层结束流程后，向关闭端发送自己的 FIN 报文，序列号和确认号同上次应答，此时状态切换为 LAST_ACK。
5. 关闭端回复 ACK 确认对端发送的 FIN 报文，序列号不变，应答号 + 1，状态切换为 TIME_WAIT，等待 2MSL 后切换为 CLOSED。
6. 被关闭端接收到最后的 ACK 后状态切换为 CLOSED。

**TIME_WAIT 状态的作用**

- **确保被动关闭方收到最后一个 ACK**：最后一个 ACK 可能丢失，被关闭方会超时重传一个 FIN 报文，TIME_WAIT 状态等待 2MSL 确保被关闭方能收到 ACK 正常关闭。
- **避免旧报文干扰新连接**：TIME_WAIT 状态新连接无法重复使用该端口号，避免新连接复用后接收到旧连接的 报文导致数据错误。

> 如果服务器频繁主动关闭连接，会积累大量 TIME_WAIT 状态的连接占用端口资源，导致新连接无法建立。
>
> 1. 调整内核参数 net.ipv4.tcp_tw_reuse 允许复用 TIME_WAIT 状态的端口。
> 2. 尽量让客户端主动关闭连接。

#### 半关闭

使用 `shutdown` 函数可以实现 TCP 连接的半关闭状态，允许连接双方关闭单向数据传输通道。

- 主动关闭发送方向：发送 FIN 报文告知对端数据已发送，不再发送数据，并清空发送缓冲区。
- 保持接收方向：可以继续接收对端发送的数据，直到对端关闭连接。
- 对端接收到 FIN 报文：对端已关闭发送数据，调用 `read` 后会返回 0。
- 对端也调用 `shutdown` 或 `close` 向主动关闭端发送 FIN 报文，完成四次挥手，连接关闭。

### 可靠传输

TCP 通过校验和、序列号、确认应答、重发控制、链接管理和窗口控制等机制实现了可靠传输。

#### 序列号

按顺序给发送数据的每个字节标记序号，接收端查询 TCP 首部的序列号和数据长度，将自己期待接收的序列号通过应答号发送回去。



## 拥塞控制

拥塞控制是 TCP 协议中用于**避免网络拥塞**、保证数据传输效率的关键机制，核心是通过**动态调整发送窗口大小**，平衡网络吞吐量和稳定性。

> 网络拥塞：发送方数据速率超过网络承载能力，导致路由器缓存溢出、丢包、延迟剧增的现象。

- **拥塞窗口 cwnd**：发送方维护的动态窗口，反应当前网络可承载的最大数据量（单位：MSS，最大报文段长度）。
- **慢启动阈值 ssthresh**：区分 “慢启动” 和 “拥塞避免” 阶段的临界值。初始值通常为较大值（如 65535 字节）。
- **实际发送窗口**：发送方的实际发送速率由 `min(cwnd, rwnd)` 决定，其中 `rwnd` 是接收方通过 TCP 头部 “窗口字段” 告知的接收窗口（流量控制，与接收缓冲区大小相关）。

### 核心算法

TCP 拥塞控制通过**慢启动、拥塞避免、快速重传、快速恢复**四个阶段实现网络拥塞程度的探测和调整。

#### 慢启动

- 连接建立后，`cwnd` 从 1 个 MSS 开始，每收到一个 ACK（确认）就增加 1 个 MSS（指数增长）。
- 当 `cwnd` 达到 `ssthresh` 时，进入 “拥塞避免” 阶段。

```cpp
static void bictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)
{
	struct tcp_sock *tp = tcp_sk(sk);
	struct bictcp *ca = inet_csk_ca(sk);

	// 判断是否受拥塞控制，RFC2861：只有当 cwnd 完全利用时才增加大小
	if (!tcp_is_cwnd_limited(sk))
		return;

	// 判断是否在慢启动阶段
	// 慢启动的条件是：发送窗口 send_cwnd < ssthresh
	if (tcp_in_slow_start(tp)) {
		if (hystart && after(ack, ca->end_seq))
			bictcp_hystart_reset(sk);
		acked = tcp_slow_start(tp, acked);
		if (!acked)
			return;
	}
	bictcp_update(ca, tp->snd_cwnd, acked);
	tcp_cong_avoid_ai(tp, ca->cnt, acked);
}

u32 tcp_slow_start(struct tcp_sock *tp, u32 acked)
{
  // cwnd 没个 ack 增加 1 个 MSS，但是不能超过 ssthresh
	u32 cwnd = min(tp->snd_cwnd + acked, tp->snd_ssthresh);
	// 与旧窗口比较，防止增长超过 ssthresh
	acked -= cwnd - tp->snd_cwnd;
	tp->snd_cwnd = min(cwnd, tp->snd_cwnd_clamp);

	return acked;
}
```

#### 拥塞避免

- `cwnd` 不再指数增长，而是每经过一个 RTT（往返时间）增加 1 个 MSS（线性增长），避免快速触发拥塞。

CUBIC 算法中，窗口增长基于三次函数，其核心是快速接近上次拥塞的窗口 last_max_cwnd，同时避免频繁拥塞。

#### 拥塞检测与响应

当检测到拥塞（丢包或延迟增加）时，调整 `ssthresh` 和 `cwnd`：

- **超时重传**：认为拥塞严重，`ssthresh = cwnd / 2`，`cwnd` 重置为 1（重新进入慢启动）。
- **收到 3 个重复 ACK**：认为发生轻微拥塞（可能仅单包丢失），触发 “快速重传” 和 “快速恢复”。