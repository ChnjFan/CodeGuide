# TCP 协议

TCP（Transmission Control Protocol，传输控制协议）是一种**面向连接的**、**可靠的**、**基于字节流**的传输层协议，由 IETF 的 RFC 793 定义。它在 IP 协议的基础上，提供了**可靠数据传输**、**流量控制**和**拥塞控制**等核心功能.。

[TOC]

## 协议报文

TCP 报文的基本头部固定 20 个字节，紧跟在 IP 数据报头部。

```shell
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-------------------------------+-------------------------------+
   |          Source Port          |       Destination Port        |
   +-------------------------------+-------------------------------+
   |                        Sequence Number                        |
   +---------------------------------------------------------------+
   |                    Acknowledgment Number                      |
   +-------+-------+-+-+-+-+-+-+-+-+-------------------------------+
   |  Data |       |C|E|U|A|P|R|S|F|                               |
   | Offset|Rsved  |W|C|R|C|S|S|Y|I|            Window             |
   |       |       |R|E|G|K|H|T|N|N|                               |
   +-------+-----------+-+-+-+-+-+-+-------------------------------+
   |           Checksum            |         Urgent Pointer        |
   +-------------------------------+-------------------------------+
   |                            Options                            |
   +---------------------------------------------------------------+
   |                             data                              |
   +---------------------------------------------------------------+
```

源端口和目的端口唯一标识 TCP 连接。

- Socket：IP + 端口
- 序列号：标识数据的每个字节序列
- 确认号：接收方期待接收的下一个序列号

## 核心特性

- 面向连接：单播协议，通过三次握手、四次挥手管理连接建立和释放。
- 可靠传输：序列号、确认机制、重传机制、校验和。
- 字节流：分组成多个 TCP 报文发送，应用层获取自己想要的数据长度。

### 面向连接

为了确保通信双方都能正常发送和接收数据，TCP 连接通过“三次握手”来建立连接，通过“四次挥手”释放连接。

#### 三次握手

使用 TCP 首部的控制字段管理连接，通过三次握手建立连接，交换通信双方的初始序列号。

建链前客户端的状态为 CLOSED，服务端启动并监听端口后初始状态为 LISTEN。

**建链流程**：

1. 客户端发送一个 SYN 报文给服务端，并携带客户端的初始序列号。客户端状态变为 SYN_SENT。
2. 服务端接收到 SYN 报文后状态变为 SYN_RCVD 并回复 SYN 报文给客户端，报文包含服务端的初始序列号，ACK 为客户端初始序列号 + 1。
3. 客户端应答服务端的 SYN 报文，将 ACK 设置为服务端初始序列号 + 1 回复给服务端。客户端状态更改为 ESTABLISHED。
4. 服务端接收到客户端应答后状态变更为 ESTABLISHED。

#### 四次挥手

通信双方都可以主动发送 FIN 报文关闭连接。

断链流程：

1. 连接关闭端发送 FIN 报文给对端，ACK 用于确认对端最近一次发送的数据，关闭端状态变更为 FIN_WAIT_1。
2. 被关闭一端发送应答报文，表明成功接收关闭请求，状态切换为 CLOSE_WAIT。
3. 关闭端接收到应答报文，状态切换为 FIN_WAIT_2，并启动定时器等待接收被关闭端的 FIN 报文。
4. 被关闭一端处理完应用层结束流程后，向关闭端发送自己的 FIN 报文，序列号和确认号同上次应答，此时状态切换为 LAST_ACK。
5. 关闭端回复 ACK 确认对端发送的 FIN 报文，序列号不变，应答号 + 1，状态切换为 TIME_WAIT，等待 2MSL 后切换为 CLOSED。
6. 被关闭端接收到最后的 ACK 后状态切换为 CLOSED。

**TIME_WAIT 状态的作用**

- **确保被动关闭方收到最后一个 ACK**：最后一个 ACK 可能丢失，被关闭方会超时重传一个 FIN 报文，TIME_WAIT 状态等待 2MSL 确保被关闭方能收到 ACK 正常关闭。
- **避免旧报文干扰新连接**：TIME_WAIT 状态新连接无法重复使用该端口号，避免新连接复用后接收到旧连接的 报文导致数据错误。

> 如果服务器频繁主动关闭连接，会积累大量 TIME_WAIT 状态的连接占用端口资源，导致新连接无法建立。
>
> 1. 调整内核参数 net.ipv4.tcp_tw_reuse 允许复用 TIME_WAIT 状态的端口。
> 2. 尽量让客户端主动关闭连接。

#### 半关闭

使用 `shutdown` 函数可以实现 TCP 连接的半关闭状态，允许连接双方关闭单向数据传输通道。

- 主动关闭发送方向：发送 FIN 报文告知对端数据已发送，不再发送数据，并清空发送缓冲区。
- 保持接收方向：可以继续接收对端发送的数据，直到对端关闭连接。
- 对端接收到 FIN 报文：对端已关闭发送数据，调用 `read` 后会返回 0。
- 对端也调用 `shutdown` 或 `close` 向主动关闭端发送 FIN 报文，完成四次挥手，连接关闭。

#### 连接队列

连接队列是 TCP 服务端用于临时存储未完成握手连接请求的缓冲区，以应对服务器对高并发连接请求的重要机制。

- 半连接队列：处于 SYN_SEND 状态的连接，长度由啮合参数 `net.ipv4.tcp_max_syn_backlog` （默认 1000）控制。
- 全连接队列：处于 ESTABLISHED 状态但未被应用程序（accept 系统调用）处理的连接，由 listen() 参数和内核参数 `net.core.somaxconn` （默认 128）共同决定。

工作流程：

1. 客户端发送 SYN 请求报文，服务端检查超过半连接队列长度，请求会被拒绝。否则将连接放入半连接队列后发送 SYN_ACK 应答报文。
2. 服务端接收到客户端的 ACK 报文后，检查全连接队列是否由空间：
   - 有空间：TCP 模块将连接放入全连接队列。
   - 没有空间：丢弃连接等待客户端超时重连，或发送 RST 报文告知客户端连接失败。

⚠️**注意**：Linux 的实现中，会在收到 SYN 报文后同时判断半连接队列和全连接队列是否满。

> 延时响应 SYN 报文：如果全连接队列满，收到 ACK 报文也无法处理，所以在收到 SYN 报文时就检查两个队列，如果无法放入全连接队列就主动延迟发送 SYN+ACK 报文。当 `tcp_abort_on_overflow=0`（默认值）会忽略客户端的 ACK，否则会直接向客户端发送 RST 报文终止连接。

#### SYN 泛洪攻击

**SYN 泛洪攻击**通过伪造大量半连接请求，耗尽服务端半链接队列资源直到超时，导致正常用户无法建立连接。

防御机制：

1. SYN Cookie 机制：服务器不维护半连接队列，通过 `SYN+ACK` 报文中的特殊 “Cookie”（基于客户端 IP、端口、时间戳等计算）验证连接合法性。客户端回复 `ACK` 时，服务器通过 Cookie 还原连接信息，仅在确认合法后才创建连接。
2. 调整半连接队列：设置连接队列长度和超时时间来避免资源耗尽。
3. 网络层过滤：防火墙/负载均衡器设置 SYN 速率限制；启用源 IP 验证；部署 DDos 高防服务，过滤攻击流量。

> 检测方法：通过 netstat 查看 SUN_RECV 数量或使用 tcpdump、流量分析工具检测。

#### TFO 机制

TCP Fast Open（TFO）是对传输控制协议（TCP）的一种扩展，用于加快两个端点之间连续 TCP 连接的打开速度。

**工作原理**：

- 首次连接请求：客户端发送 SYN 报文，报文中包含 Fast Open 选项，且该选项的 Cookie 为空，表示客户端请求 Fast Open Cookie。
  - 服务端支持 Fast OPen，生成 Cookie 后在 SYN+ACK 报文的 FastOpen 选项中返回客户端。
  - 客户端收到 Cookie 后缓存。
- 后续连接建立：客户端再次向服务器建立连接时，发送的 SYN 报文会包含**数据**以及本地缓存的 **Fast Open Cookie**。
  - Cookie 有效：完成建链，并将数据应答返回给客户端。
  - Cookie 无效：丢弃数据，确认报文只有序列号，完成建链后客户端重新发送数据。

使用场景：延迟敏感且请求具有幂等性的应用，如 HTTP 的 GET 请求等。不适用长连接应用，如在线视频、实时通信等。

### 可靠传输

TCP 通过校验和、序列号、确认应答、重发控制、链接管理和窗口控制等机制实现了可靠传输。

#### 序列号

按顺序给发送数据的每个字节标记序号，接收端查询 TCP 首部的序列号和数据长度，将自己期待接收的序列号通过应答号发送回去。

 #### 超时重传

- 重传超时计时器（RTO）：发送数据时设置定时器，定时器超时未收到 ACK 后进行重传。
- 快速重传：发送方收到失序的 ACK，判定出现丢包后进行重传。

**超时重传计时器**

- 解决网络中数据包丢失的问题（如链路故障、拥塞丢弃等）
- 保证 TCP 传输的可靠性

超时重传的关键参数是 RTO（重传超时时间），需要略大于当前网络 RTT。

在连接设定的 RTO 内没有收到被计时报文段的 ACK，将会触发超时重传。

#### 快速重传

核心逻辑：不等超时重传定时器到，发送方接收到重复 3-5 个冗余的 ACK 报文，主动判断数据丢失并立即重传。

**工作流程**：

1. 发送方发送数据给接收方，其中某个数据报文段丢失后，发送方仍发送后续数据；
2. 接收方接收到后续数据后，重复向发送方返回丢失数据前一报文的 ACK；
3. 发送方重复收到三个丢失数据前一报文的 ACK 后，判定数据丢失重新发送，无需等到超时。

| 对比维度             | 快速重传（Fast Retransmit）                           | 超时重传（Timeout Retransmit）                    |
| -------------------- | ----------------------------------------------------- | ------------------------------------------------- |
| **触发条件**         | 收到 **3 个连续的冗余 ACK**                           | **超时计时器（RTO）到期**，未收到对应 ACK         |
| **触发依据**         | 接收方的主动反馈（冗余 ACK）                          | 发送方的被动等待（计时器）                        |
| **重传延迟**         | 极短（毫秒级，取决于发送后续数据的频率）              | 较长（秒级，且 RTO 会指数翻倍）                   |
| **适用场景**         | 单个 / 少数数据段丢失（网络轻度拥堵，接收方正常工作） | 数据段或 ACK 完全丢失（网络严重拥堵、链路中断）   |
| **对拥塞控制的影响** | 仅触发 “快速恢复”（发送窗口小幅调整），吞吐量稳定     | 触发 “慢启动”（发送窗口骤降为 1），吞吐量大幅下降 |
| **网络状态判断**     | 判定为 “轻度拥堵”（仅丢失个别数据，无需大幅降速）     | 判定为 “严重拥堵”（需大幅降速以避免加剧拥堵）     |

#### 选择确认机制

选择确认机制（SACK）用于解决传统 “累计确认” 机制的局限性，接收方在 ACK 报文中**明确告知发送方 “哪些不连续的数据段已成功接收”**，从而让发送方仅重传真正丢失的数据段，避免冗余重传。

> 传统累计确认机制：接收方返回的 ACK 确认号仅表示 “已成功接收的连续数据的最后一个序号”。例如：
>
> - 发送方发送数据段 M1（1-100）、M2（101-200）、M3（201-300）、M4（301-400）；
> - 若 M2 和 M4 丢失，接收方仅能收到 M1 和 M3；
> - 此时接收方只能返回 ACK=101（表示已收到 1-100，期望下一个是 101），无法告知发送方 “M3 已收到”。

接收端 TCP 连接建立期间收到选项中的 SACK 许可即可生成 SACK，标记一个或多个 “已接收的不连续数据段范围”（以 “起始序号 - 结束序号” 表示）。

## 流量控制

流量控制机制的核心目标是**避免发送方发送速率过快，导致接收方缓冲区溢出**，从而确保数据传输的可靠性和效率。其实现依赖于**滑动窗口机制**（Sliding Window Mechanism），并通过 TCP 报文头中的 “窗口大小”（Window Size）字段传递控制信息。

接收方根据自身**接收缓冲区（Receive Buffer）的剩余空间**，动态告知发送方可发送的最大数据量（即 “窗口大小”），发送方严格遵循该窗口限制调整发送速率。

1. 接收方维护一个固定大小的接收缓冲区，用于暂存已接收但未被应用层读取的数据；
2. 接收方计算缓冲区的**剩余空间**，将该剩余空间作为 “窗口大小” 写入 TCP 报文头，随 ACK 报文发送给发送方；
3. 发送方收到 ACK 后，将 “窗口大小” 作为当前可发送数据的上限，仅发送不超过该大小的数据；
4. 当接收方的应用层读取了缓冲区中的数据后，缓冲区剩余空间增大，接收方会再次通过 ACK 告知发送方更新后的窗口大小，允许发送方继续发送更多数据。

### 滑动窗口

TCP 连接的两端各自维护一个**发送窗口**和**接收窗口**，通过不断调整窗口大小和移动来动态调整发送速率。

#### 接收窗口（Receiver Window, rwnd）

接收端维护的接收窗口用来告知发送端可以接收的数据范围，记录了已接收并确认的数据，以及能够接收的最大序列号。

- 初始状态：接收方刚建立连接时，会将缓冲区总大小作为初始窗口大小，通过 SYN 报文（连接建立请求）告知发送方；
- 动态更新：每次接收方应用层读取数据后，缓冲区剩余空间增加，会在后续的 ACK 报文中更新窗口大小；
- 特殊情况：若接收缓冲区已满（剩余空间为 0），接收方会将窗口大小设为 0（即 “零窗口”），此时发送方需停止发送数据，避免缓冲区溢出。

#### 发送窗口（Sender Window, swnd）

发送窗口是发送方根据接收方的提供窗口（offered window）维护的 “可发送数据范围”，决定了发送方可主动发送的数据量。

- 窗口结构：发送窗口分为三个区域。
  - **已发送且已确认**：字节序号小于窗口左边界，无需再处理；
  - **已发送但未确认**：字节序号在窗口内，等待接收方 ACK；
  - **未发送但可发送**：字节序号在窗口内，可随时发送（不超过窗口大小）；
- 窗口滑动：当发送方收到接收方的 ACK 报文，会将窗口左边界向右移动到 “已确认字节的下一个序号”，同时根据 ACK 中的新窗口大小调整窗口右边界，实现 “窗口滑动”，释放新的可发送空间。

#### 零窗口和窗口探测

接收方将窗口大小设置为 0 可以阻止发送端继续发送，直到窗口大小恢复为非 0 值。

接收端的接收窗口重新获得空间后会给发送端传输一个**窗口更新**报文，告知发送端可以继续发送数据。

发送方定期发送**窗口探测**报文（1 字节数据），询问接收方是否有可用缓冲区，防止窗口更新报文丢失导致连接双方一直处于等待状态。

#### 糊涂窗口综合征

糊涂窗口综合征（Silly Window Syndrome）是 TCP 连接中因接收端通告较小的窗口大小，致使发送端频繁发送大量小包，进而降低网络利用率甚至引发拥塞的状况。

**接收端策略**：

- 延迟确认：接收端缓存的空闲空间小于 MSS 或缓存空间一半时，不立即向发送端通告窗口更新，而是等待应用层读取更多数据，使空闲空间足够大后再发送确认报文，附带较大的窗口信息。
- TCP 接收端收到窗口探测报文后需要响应当前窗口大小。

**发送端策略**：

- **Nagle 算法**：满足下面条件其中一条后才发送数据包。
  - 发送缓冲区的数据量达到 MSS 或紧急数据。
  - 数据段长度大于等于接收端通告过最大窗口值一半时。
  - 没有未经确认的在传数据（所有发送的数据都已经收到 ACK 报文）。

## 拥塞控制

拥塞控制是 TCP 协议中用于**避免网络拥塞**、保证数据传输效率的关键机制，核心是通过**动态调整发送窗口大小**，平衡网络吞吐量和稳定性。

> 网络拥塞：发送方数据速率超过网络承载能力，导致路由器缓存溢出、丢包、延迟剧增的现象。

- **拥塞窗口 cwnd**：发送方维护的动态窗口，反应当前网络可承载的最大数据量（单位：MSS，最大报文段长度）。
- **慢启动阈值 ssthresh**：区分 “慢启动” 和 “拥塞避免” 阶段的临界值。初始值通常为较大值（如 65535 字节）。
- **实际发送窗口**：发送方的实际发送速率由 `min(cwnd, rwnd)` 决定，其中 `rwnd` 是接收方通过 TCP 头部 “窗口字段” 告知的接收窗口（流量控制，与接收缓冲区大小相关）。

### 核心算法

TCP 拥塞控制通过**慢启动、拥塞避免、快速重传、快速恢复**四个阶段实现网络拥塞程度的探测和调整。

#### 慢启动

- 连接建立后，`cwnd` 从 1 个 MSS 开始，每收到一个 ACK（确认）就增加 1 个 MSS（指数增长）。
- 当 `cwnd` 达到 `ssthresh` 时，进入 “拥塞避免” 阶段。

```cpp
static void bictcp_cong_avoid(struct sock *sk, u32 ack, u32 acked)
{
	struct tcp_sock *tp = tcp_sk(sk);
	struct bictcp *ca = inet_csk_ca(sk);

	// 判断是否受拥塞控制，RFC2861：只有当 cwnd 完全利用时才增加大小
	if (!tcp_is_cwnd_limited(sk))
		return;

	// 判断是否在慢启动阶段
	// 慢启动的条件是：发送窗口 send_cwnd < ssthresh
	if (tcp_in_slow_start(tp)) {
		if (hystart && after(ack, ca->end_seq))
			bictcp_hystart_reset(sk);
		acked = tcp_slow_start(tp, acked);
		if (!acked)
			return;
	}
	bictcp_update(ca, tp->snd_cwnd, acked);
	tcp_cong_avoid_ai(tp, ca->cnt, acked);
}

u32 tcp_slow_start(struct tcp_sock *tp, u32 acked)
{
  // cwnd 没个 ack 增加 1 个 MSS，但是不能超过 ssthresh
	u32 cwnd = min(tp->snd_cwnd + acked, tp->snd_ssthresh);
	// 与旧窗口比较，防止增长超过 ssthresh
	acked -= cwnd - tp->snd_cwnd;
	tp->snd_cwnd = min(cwnd, tp->snd_cwnd_clamp);

	return acked;
}
```

#### 拥塞避免

- `cwnd` 不再指数增长，而是每经过一个 RTT（往返时间）增加 1 个 MSS（线性增长），避免快速触发拥塞。

CUBIC 算法中，窗口增长基于三次函数，其核心是快速接近上次拥塞的窗口 last_max_cwnd，同时避免频繁拥塞。

#### 拥塞检测与响应

当检测到拥塞（丢包或延迟增加）时，调整 `ssthresh` 和 `cwnd`：

- **超时重传**：认为拥塞严重，`ssthresh = cwnd / 2`，`cwnd` 重置为 1（重新进入慢启动）。
- **收到 3 个重复 ACK**：认为发生轻微拥塞（可能仅单包丢失），触发 “快速重传” 和 “快速恢复”。

