# HTTP 协议

HTTP（Hypertext Transfer Protocol，超文本传输协议）是**用于在客户端和服务器之间传输超文本（如 HTML、图片、视频等）的应用层协议**，是 Web 的应用层协议。通过客户端向服务端建立 TCP 连接传输数据。

[TOC]

## 报文格式

HTTP 请求报文由**请求行、请求头、空行、请求体**四部分组成：

```http
GET /index.html HTTP/1.1  // 请求行
Host: www.example.com     // 请求头（键值对）
User-Agent: Chrome/90.0.0.0
Accept: text/html,application/xhtml+xml

username=test&password=123  // 请求体（可选，如POST数据）
```

- 请求行：包括操作类型（GET、POST、HEAD、PUT 和 DELETE），URL 字段（目标资源路径）和 HTTP 版本号（HTTP/1.1、HTTP/2）。
- 请求头：使用键值对描述请求的附加信息。
  - Host：服务器域名或 IP 地址。
  - User-Agent：客户端身份信息。
  - Content-Type：请求体的数据格式。
  - Cookie：客户端存储的会话信息。
  - Connection：值为 Keep-Alive 使用长连接机制。HTTP/1.1 版本默认是长连接，为了兼容旧版本设置该字段。
  - Accept：告知服务端自己可以接受的数据格式。
- 请求体：向服务器提交数据时存在。

HTTP 响应报文由**状态行、响应头、空行、响应体**四部分组成：

```http
HTTP/1.1 200 OK  // 状态行
Date: Mon, 31 Oct 2025 12:00:00 GMT  // 响应头
Content-Type: text/html; charset=utf-8
Content-Length: 1024

<html><body>Hello World</body></html>  // 响应体（资源内容）
```

- 状态行：协议版本字段、状态码和状态描述信息
- 响应头：使用键值对描述响应附加信息。
  - Content-Type：响应体的数据格式。
  - Content-Length：响应体的字节长度。
  - Set-Cookie：服务端向客户端设置 Cookie。
  - Cache-Control：缓存控制策略。
- 响应体：服务器返回资源内容。

### 请求类型

GET 操作是从服务器获取指定的资源，获取的资源可以是静态文本、页面、图片视频等。

GET 请求的参数一般写在 URL 中，参数只允许 ASCII 字符，且浏览器对长度有限制，例如：

```http
GET /index.html?key1=value1 HTTP/1.1
```

POST 操作是向服务器提交新资源或数据（表单提交、上传文件等）。

> HTTP 协议中的**安全**是指请求方法不会破坏服务器上的资源。
>
> 幂等是指多次执行相同的操作，结果都是相同的。

GET 方法是安全且幂等的，因为是只读操作，无论多少次操作，服务器的数据都是安全的，且每次请求结果都是相同的。浏览器可以对 GET 请求数据做缓存。

POST 方法是新增或提交数据的操作，会修改服务器上的资源，且多次提交数据会创建多个资源，所以不是安全啊也不是幂等的。浏览器一般不会缓存 POST 请求。

### 状态码

HTTP 状态码是服务器对客户端请求的结果，共五大类。

1. **1xx（信息性状态码）：请求已接收，需继续处理**
2. **2xx（成功状态码）：请求已成功处理**
   - **200 OK**：请求完全成功，响应体包含请求的资源（如 GET 网页、API 查询数据）。
   - **204 No Content**：请求成功，但响应体无内容（多用于 DELETE 请求、只需要确认状态的操作）。
   - **206 Partial Content**：部分内容请求成功（客户端通过 Range 头请求文件片段，如视频断点续传、大文件分块下载）。

3. **3xx（重定向状态码）：需客户端进一步操作**

   重定向状态码表示客户端请求的资源发生变动，需要客户端使用新的 URL 重新获取资源。

   - **301 Moved Permanently**：资源永久迁移到新 URL，后续请求需使用新地址（浏览器会缓存该重定向，下次直接访问新 URL）。
   - **302 Found**：资源临时迁移到新 URL，下次请求仍可使用原地址（不缓存，常用于临时跳转，如登录后跳回原页面）。
   - **304 Not Modified**：资源未修改（客户端携带缓存验证信息，如 If-Modified-Since，服务器告知可直接使用本地缓存，无需重新传输资源）。

4. **4xx（客户端错误状态码）：请求有误，服务器无法处理**
   - **400 Bad Request**：请求参数错误、格式非法（如 JSON 语法错误、表单字段缺失，服务器无法解析）。
   - **403 Forbidden**：服务器拒绝请求（已认证，但无访问权限，如普通用户访问管理员接口、IP 被拉黑）。
   - **404 Not Found**：请求的资源不存在（URL 错误、资源已删除，是最常见的客户端错误）。

5. **5xx（服务器错误状态码）：服务器处理请求时出错**
   - **500 Internal Server Error**：服务器通用错误（最常见的服务器错误，如代码 Bug、数据库连接失败，具体原因需看服务器日志）。
   - **501 Not Implemented**：服务器未实现该请求方法（如客户端用了服务器不支持的扩展方法）。
   - **502 Bad Gateway**：网关错误（服务器作为网关 / 代理，从上游服务器接收了无效响应，如反向代理后后端服务宕机）。
   - **503 Service Unavailable**：服务暂时不可用（服务器过载、维护中，通常是临时状态，响应头可能包含 Retry-After 告知重试时间）。

### HTTP 版本

1. **HTTP/1.0** 使用短链接，每次请求都需要建立 TCP 链接。

2. **HTTP/1.1** 版本默认使用长连接（Connection: keep-alive），是目前应用最广泛的版本。
   - 管道化请求（未被浏览器支持）：客户端不需要等请求应答就可以发送其他请求到服务端，减少整体响应时间。
   - 队头阻塞：顺序发送的请求中只要一个请求被阻塞，后面排队的请求也被阻塞，导致客户端一直请求不到数据。
3. HTTP/2 版本采用二进制传输、多路复用和服务器主动推送来提升性能。
   - 头部压缩：协议头部进过压缩后发送，HPACK 算法就是在客户端和服务端维护头信息表，所有字段存入表中，相同字段只发送索引号。
   - 二进制传输：头信息和数据体都使用二进制传输，减少传输数据长度。
   - 多路复用：多个 Stream 复用在一条 TCP 链接，解决队头阻塞问题。
     - Stream 里可以包含多个 Message，其中 Message 就是对应 HTTP/1 中的请求和响应，由 HTTP 头部和包构成。
     - Message 可以包含多个 Frame，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容。
   - 服务器推送：服务器可以主动向客户端发送消息。
4. HTTP/3 版本基于 UDP 的 QUIC 协议减少握手延迟，解决队头阻塞问题。
   - 无队头阻塞：某个 Stream 出现丢包时，只会阻塞对应 Stream，其他 Stream 不受影响。
   - 更快建链过程：QUIC 内部包含 TLS，只需要 1 个 RTT 就可以完成建链和密钥协商。
   - 连接迁移：TCP 链接使用四元组确定连接，网络切换需要断链后重新建链。QUIC 使用链接 ID 标记通信的两个端点。IP 地址变化只要有上下文信息，就可以复用链接。

## 核心特性

HTTP 协议的特性用于解决通信中效率、安全和状态管理等问题的关键机制。

### 缓存机制

缓存机制是减少重复请求，通过对具有重复性的 HTTP 请求的数据进行缓存，提升客户端加载性能的核心手段。

HTTP 的缓存实现有两种方式：强制缓存和协商缓存。

#### 强制缓存

浏览器可以直接复用本地缓存的资源，不再向服务器发送请求，客户端判断缓存是否有效。

服务器响应首次请求时携带缓存有效时间，客户端以此判断缓存是否可用。

- **`Cache-Control: max-age=N`**（优先级最高）
  - `N` 为秒数，表示缓存从生成时刻起，`N` 秒内有效。
- **`Expires: 具体时间`**（HTTP/1.0 遗留字段）
  - 格式为 GMT 时间（如 `Expires: Wed, 20 Jul 2025 12:00:00 GMT`），表示缓存到该时间点失效。

工作流程：

1. 客户端首次请求资源，服务器返回资源并附带 `Cache-Control: max-age=3600`。
2. 浏览器将资源缓存在本地，记录缓存生成时间和有效期。
3. 有效期内请求浏览器直接从缓存读取。
4. 超过有效期后强制缓存失效，进入协商缓存流程。

#### 协商缓存

强制缓存失效后，浏览器需要向服务器确认缓存是否可以继续使用。

服务器响应资源时携带资源的唯一标识，浏览器确认缓存时需要携带该标识：

- `ETag: "xxx"`（高优先级）服务端响应资源标识。
- `If-None-Match: "xxx"` 浏览器请求确认缓存携带资源标识。
- `Last-Modified: 时间` 服务端返回资源最后修改时间，精度低，资源在秒级内变更无法识别。
- `If-Modified-Since: 时间` 浏览器请求确认缓存携带最后修改时间。

工作流程：

1. 强制缓存失效后，浏览器发起缓存请求确认，携带`If-None-Match`（或 `If-Modified-Since`）。
2. 服务器对比请求头与资源的当前状态：
   - 资源标识相同（时间一致），返回 `304 Not Modified` 浏览器可以继续复用本地缓存。
   - 资源标识不同（时间不一致），返回 `200 OK` 以及新的资源，浏览器更新缓存资源。

### 状态管理

HTTP 协议是无状态协议，实际应用中需要状态管理来满足识别用户和维持会话的复杂交互需求。

> 无状态协议：每次请求都是独立的，服务器只处理当前请求信息，不记录客户端历史请求。无状态设计让 HTTP 协议更简单高效。

Web 应用通常需要维持用户的登录状态，记录用户配置，支持连续的业务流程等，因此需要状态管理。

HTTP 协议通过 Cookie 和 Session、Token、JWT 等实现状态管理，让服务器能识别客户端请求的用户会话信息。

#### Cookie 和 Session

1. 客户端首次发送 HTTP 请求。
2. 服务端创建 Session 会话并生成唯一的 SessionID，通过响应报文的 `Set-Cookie: sessionId=xxx; HttpOnly; Path=/` 发送给客户端。 
3. 客户端将会话 ID 作为 Cookie 存储在本地，后续请求在请求头中携带 Cookie 字段。
4. 服务端更具携带的 Cookie 查找到对应会话，识别本次 HTTP 请求的会话。

#### Token

前后端分离和分布式系统下，服务器不再存储状态，仅验证请求的 Token 有效性。

1. 客户端登录并获取 Token。

   用户提交账户密码，服务端验证后生成 Token（加密字符串，包含用户 ID、过期时间等信息），直接返回给客户端。

2. 客户端存储 Token，后续每次携带 Token

   客户端每次请求时，在请求头 `Authorization: Bearer <token>` 中携带 Token。

3. 服务器验证 Token。

   服务器接收到 Token 后，解密进行验证 Token 的有效性，用户是否认证，或 Token 是否过期。

## HTTPS 协议

HTTP 协议信息是明文传输，存在安全风险问题，HTTPS 在 TCP 和 HTTP 网络层之间加入了 [SSL/TLS](./tls.md) 安全协议，实现数据传输的加密、身份验证和完整性校验。

### 混合加密

HTTPS 采用对称加密和非对称加密结合的混合加密方式：

- 通信建立前采用非对称加密方式交换会话密钥。
- 通信过程中使用对称加密的会话密钥加密明文数据。

### 数字签名

为了保证传输数据的完整性，HTTPS 报文需要使用摘要算法计算出传输内容的哈希值，协同报文一起传输给对端。对端收到后同样计算一次传输内容的哈希值，如果与携带的值相同则认为内容没有被篡改。

为了保证内容的哈希值不被中间人篡改，需要使用**数字签名算法**对哈希值进行加密，来确认消息的身份。

- **公钥加密，私钥解密**：保证内容传输的安全，公钥加密的内容只有持有私钥的人才能解密。
- **私钥加密，公钥解密**：保证消息不被其他人篡改，只有持有私钥的人才能加密，因此用公钥正常解密出来的内容一定是持有私钥的人加密发送的。

### 数字证书

为了防止获取的公钥是中间人伪造，导致数据被中间人窃取并伪造，需要保证客户端获取的公钥是服务端发布的。

数字证书包含个人信息、公钥和数字签名等信息，服务端将数字证书注册到 CA（数字证书认证机构），所有客户端都向 CA 获取服务端的数字证书。

工作流程：

1. 服务器将自己的公钥注册到 CA。
2. CA 用自己的私钥加密服务器公钥和数字签名颁发数字证书。
3. 浏览器中已经保存 CA 的公钥，客户端获取服务器的数字证书后验证正确性。
4. 客户端从获取的数字证书中获取服务器的公钥，加密报文后发送给服务器。
5. 服务器使用私钥对报文进行解密。

### 相关问题

1. **HTTPS 协议一定安全可靠吗？**

问题场景：客户端通过浏览器向服务端发起 HTTPS 请求时，如果被假基站转发到一个中间人服务器，客户端和中间人服务器完成了 TLS 握手，然后中间人服务器再与真正的服务端完成 TLS 握手。

中间人服务器与客户端在 TLS 握手过程中，实际上发送的是自己伪造的证书给浏览器，这个伪造的证书可以被浏览器识别出是非法的，提醒客户端证书不是受信任的机构颁发。如果用户接受中间人伪造证书，那后续 HTTPS 的通信都能被中间人监听。

2. **为什么抓包工具能截取 HTTPS 数据？**

抓包工具能看到明文的 HTTPS 数据，工作原理更中间人是一致的。

在客户端抓包，抓包工具可以作为客户端与真实服务端建立链接，服务端不会校验客户端身份。

在服务端抓包，抓包工具作为服务端与客户端建立链接，需要有对应服务端的私钥才可以与客户端建立链接。

抓包工具自己签发证书，客户端安装 Fiddler 根证书，将抓包工具生成的证书导入系统受信任的证书列表中，这样浏览器就可以用抓包工具签发的证书到抓包工具自己的 CA 认证。



